import{_ as t,F as p,g as e,K as n,h as a,ar as l,l as s,o as h}from"./chunks/framework.VlluEs-f.js";const I=JSON.parse('{"title":"20工厂方法模式：如何解决生成对象时的不确定性？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/趣学设计模式_文档/(6885) 20  工厂方法模式：如何解决生成对象时的不确定性？.md","filePath":"posts/backEnd/趣学设计模式_文档/(6885) 20  工厂方法模式：如何解决生成对象时的不确定性？.md","lastUpdated":1718371218000}'),E={name:"posts/backEnd/趣学设计模式_文档/(6885) 20  工厂方法模式：如何解决生成对象时的不确定性？.md"},r=l("",9),o=l("",37),k=s("p",null,[a("这里尤其要注意的是，工厂方法模式和抽象工厂模式虽然都用于创建对象，但是两者的侧重点是完全不同的。"),s("strong",null,"工厂方法模式侧重于继承的连续性，而抽象工厂模式侧重于组合的扩展性"),a("，这就导致了工厂方法模式会更多去关注是否满足里氏替换原则，而抽象工厂模式很多时候是要寻找到更好的抽象产品，这期间很有可能是会违反里氏替换原则的。")],-1),g=s("h3",{id:"课后思考",tabindex:"-1"},[a("课后思考 "),s("a",{class:"header-anchor",href:"#课后思考","aria-label":'Permalink to "课后思考"'},"​")],-1),c=s("p",null,"在文中 LogFactory 的代码实现里，如果不使用静态加载来实现具体产品的初始化的话，要想实现接入更多日志组件的话，该如何实现呢？",-1),d=s("p",null,"欢迎留言分享，我会第一时间给你回复。",-1),u=s("p",null,'在下一讲，我会接着与你分享"原型模式：什么场景下需要用到对象拷贝？"这个话题，记得按时来听课！',-1);function y(m,_,b,v,L,q){const i=p("Image");return h(),e("div",null,[r,n(i,{alt:"image (4).png",src:"https://s0.lgstatic.com/i/image6/M00/40/38/CioPOWCjk6qAJLeiAADWU3qiKQg267.png"}),a(),o,n(i,{alt:"设计模式20--金句.png",src:"https://s0.lgstatic.com/i/image6/M00/40/2F/Cgp9HWCjk9yAAngzAAYesuPxHzg864.png"}),a(),k,g,c,d,u])}const f=t(E,[["render",y]]);export{I as __pageData,f as default};
