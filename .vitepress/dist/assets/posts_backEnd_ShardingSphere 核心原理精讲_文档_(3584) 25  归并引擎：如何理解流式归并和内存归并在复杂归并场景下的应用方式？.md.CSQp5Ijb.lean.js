import{_ as h,F as l,g as k,K as n,h as i,ar as t,l as s,o as p}from"./chunks/framework.VlluEs-f.js";const v=JSON.parse('{"title":"25归并引擎：如何理解流式归并和内存归并在复杂归并场景下的应用方式？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/ShardingSphere 核心原理精讲_文档/(3584) 25  归并引擎：如何理解流式归并和内存归并在复杂归并场景下的应用方式？.md","filePath":"posts/backEnd/ShardingSphere 核心原理精讲_文档/(3584) 25  归并引擎：如何理解流式归并和内存归并在复杂归并场景下的应用方式？.md","lastUpdated":1718371218000}'),e={name:"posts/backEnd/ShardingSphere 核心原理精讲_文档/(3584) 25  归并引擎：如何理解流式归并和内存归并在复杂归并场景下的应用方式？.md"},E=t("",10),r=t("",8),g=s("ul",null,[s("li",null,[s("strong",null,"第二次 next 调用")])],-1),d=s("p",null,'与此同时，所有数据结果集中的游标都将下移至"task1"的下一个不同的数据值，并且根据数据结果集当前游标指向的值进行重排序。在上图中，我们看到第二个"task2"同时存在于 health_task0 和 health_task1 中，这样包含名字为"task2"的相关数据结果集则排在的队列的前列。',-1),y=s("p",null,[i("当再次执行 next 调用时，我们获取了 "),s("strong",null,'"task2"'),i(" 的分数并进行了累加，即 42+50=92，如下图中所示：")],-1),F=t("",58);function c(o,u,A,D,C,B){const a=l("Image");return p(),k("div",null,[E,n(a,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/4B/9B/CgqCHl9V6UOALvzxAAB7G9wGDzY482.png"}),i(),r,n(a,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/4B/9B/CgqCHl9V6V6AO3mBAAB_3I9Nrm8196.png"}),i(),g,d,y,n(a,{alt:"Lark20200907-164326.png",src:"https://s0.lgstatic.com/i/image/M00/4B/99/Ciqc1F9V8tmAFpx-AAB_pY0rk9I059.png"}),i(),F])}const b=h(e,[["render",c]]);export{v as __pageData,b as default};
