import{_ as n,F as h,g as k,K as p,h as i,l as s,ar as l,o as t}from"./chunks/framework.VlluEs-f.js";const v=JSON.parse('{"title":"第06讲：谈谈你对锁的理解？如何手动模拟一个死锁？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Java 源码剖析 34 讲_文档/(1766) 第06讲：谈谈你对锁的理解？如何手动模拟一个死锁？.md","filePath":"posts/backEnd/Java 源码剖析 34 讲_文档/(1766) 第06讲：谈谈你对锁的理解？如何手动模拟一个死锁？.md","lastUpdated":1718371218000}'),e={name:"posts/backEnd/Java 源码剖析 34 讲_文档/(1766) 第06讲：谈谈你对锁的理解？如何手动模拟一个死锁？.md"},E=s("h1",{id:"第06讲-谈谈你对锁的理解-如何手动模拟一个死锁",tabindex:"-1"},[i("第06讲：谈谈你对锁的理解？如何手动模拟一个死锁？ "),s("a",{class:"header-anchor",href:"#第06讲-谈谈你对锁的理解-如何手动模拟一个死锁","aria-label":'Permalink to "第06讲：谈谈你对锁的理解？如何手动模拟一个死锁？"'},"​")],-1),r=s("p",null,[i("在并发编程中有两个重要的概念："),s("strong",null,"线程和锁"),i('，多线程是一把双刃剑，它在提高程序性能的同时，也带来了编码的复杂性，对开发者的要求也提高了一个档次。而锁的出现就是为了保障多线程在同时操作一组资源时的数据一致性，当我们给资源加上锁之后，只有拥有此锁的线程才能操作此资源，而其他线程只能排队等待使用此锁。当然，在所有的面试中也都少不了关于"锁"方面的相关问题。')],-1),d=s("p",null,"我们本课时的面试题是，如何手动模拟一个死锁？谈谈你对锁的理解。",-1),g=s("h3",{id:"典型回答",tabindex:"-1"},[i("典型回答 "),s("a",{class:"header-anchor",href:"#典型回答","aria-label":'Permalink to "典型回答"'},"​")],-1),y=s("p",null,"死锁是指两个线程同时占用两个资源，又在彼此等待对方释放锁资源，如下图所示：",-1),c=l("",42);function F(o,A,D,C,u,B){const a=h("Image");return t(),k("div",null,[E,r,d,g,y,p(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7D/29/Cgq2xl59tsKAQ8wtAAA5YT3tSNk931.png"}),i(),c])}const _=n(e,[["render",F]]);export{v as __pageData,_ as default};
