import{_ as l,F as t,g as k,K as n,h as i,l as s,ar as h,o as e}from"./chunks/framework.VlluEs-f.js";const M=JSON.parse('{"title":"加餐1：DataCarrier实现详解","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(2946) 加餐1：DataCarrier 实现详解.md","filePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(2946) 加餐1：DataCarrier 实现详解.md","lastUpdated":1718371218000}'),p={name:"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(2946) 加餐1：DataCarrier 实现详解.md"},r=s("h1",{id:"加餐1-datacarrier实现详解",tabindex:"-1"},[i("加餐1：DataCarrier实现详解 "),s("a",{class:"header-anchor",href:"#加餐1-datacarrier实现详解","aria-label":'Permalink to "加餐1：DataCarrier实现详解"'},"​")],-1),E=s("p",null,"在开始介绍 Trace 相关 BootService 实现以及 Trace 数据的收集和发送之前，我们需要了解另一个关键的组件 ------ DataCarrier 。DataCarrier 是一个轻量级的生产者-消费者模式的实现库， SkyWalking Agent 在收集到 Trace 数据之后，会先写入到 DataCarrier 中的缓存，然后由后台线程定时发送到后端的 OAP。其实，在多数涉及网络传输的场景中都会使用这种设计：先在本地缓存数据，然后聚合，最后定时批量发送。",-1),d=s("p",null,"DataCarrier 之前是一个单独的项目，现在并入 SkyWalking 之中作为一个独立的子模块存在，具体位置如下图所示：",-1),g=h("",13),o=h("",4),y=h("",4),c=h("",4),u=h("",5),C=s("h4",{id:"idriver-实现剖析",tabindex:"-1"},[i("IDriver 实现剖析 "),s("a",{class:"header-anchor",href:"#idriver-实现剖析","aria-label":'Permalink to "IDriver 实现剖析"'},"​")],-1),A=s("p",null,"IDriver 接口会将前文介绍的 IConsumer 消费者以及 ConsumerThread 线程或 MultipleChannelsConsumer 线程按照一定的消费模式集成到一起，提供更加简单易用的 API。",-1),D=s("p",null,"IDriver 接口的继承关系如下图所示，其中依赖 ConsumerThread 的实现是 ConsumerDriver ，依赖 MultipleChannelsConsumer 的实现是 BulkConsumerPool ：",-1),F=h("",11),m=s("p",null,"下图的 consume() 方法重载则是依赖传入的 BulkConsumePool 实现数据消费能力的（注意，这里不会新建 BulkConsumePool）：",-1),f=s("p",null,"这里传入的 BulkConsumePool 对象一般统一维护在 ConsumerPoolFactory 中。ConsumerPoolFactory 是通过枚举方式实现的单例类，其底层维护了一个 Map<String, ConsumerPool> 集合，其中 Key 就是 BulkConsumePool 的名称，后面会看到大量通过名称在 ConsumerPoolFactory 中查找 BulkConsumePool 对象的场景。",-1),B=s("h4",{id:"总结",tabindex:"-1"},[i("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),_=s("p",null,"本课时主要介绍了 DataCarrier 这个轻量级的生产者-消费者模式的实现库，首先介绍了 DataCarrier 最底层的数据存储组件 Buffer 和 Channels 以及相关的填充策略，接下来深入分析了 DataCarrier 提供的消费者接口以及两种消费模型，最后介绍了 IDriver 接口和 DataCarrier 门面类提供的 API 实现。",-1);function b(v,T,I,P,S,L){const a=t("Image");return e(),k("div",null,[r,E,d,n(a,{alt:"sw1.png",src:"https://s0.lgstatic.com/i/image3/M01/8B/D8/Cgq2xl6enDGAd7mqAAF-K97sPzE781.png"}),i(),g,n(a,{alt:"sw2.png",src:"https://s0.lgstatic.com/i/image3/M01/8B/D9/Cgq2xl6enRKAKlx5AAAlHmaDotA329.png"}),i(),o,n(a,{alt:"sw3.png",src:"https://s0.lgstatic.com/i/image3/M01/05/95/CgoCgV6enVKAMtBMAABQyIHkIPs184.png"}),i(),y,n(a,{alt:"sw4.png",src:"https://s0.lgstatic.com/i/image3/M01/8B/DA/Cgq2xl6enYSAPp8SAADKo6QU_14981.png"}),i(),c,n(a,{alt:"sw5.png",src:"https://s0.lgstatic.com/i/image3/M01/05/95/CgoCgV6eneaAei7OAACQCaME7Fk880.png"}),i(),u,n(a,{alt:"sw6.png",src:"https://s0.lgstatic.com/i/image3/M01/8B/DA/Cgq2xl6enhKADPe-AAIoMSB90P4701.png"}),i(),C,A,D,n(a,{alt:"sw7.png",src:"https://s0.lgstatic.com/i/image3/M01/05/95/CgoCgV6enimAbhHkAAIykJeqP-I840.png"}),i(),F,n(a,{alt:"sw8.png",src:"https://s0.lgstatic.com/i/image3/M01/12/C5/Ciqah16enoiAAR34AABZQEoOOp8211.png"}),i(),m,n(a,{alt:"sw9.png",src:"https://s0.lgstatic.com/i/image3/M01/05/96/CgoCgV6enpaAGX-EAAAccs9p1lw523.png"}),i(),f,B,_])}const V=l(p,[["render",b]]);export{M as __pageData,V as default};
