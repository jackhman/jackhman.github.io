import{_ as t,F as p,g as e,K as a,h as s,ar as h,l as n,o as l}from"./chunks/framework.VlluEs-f.js";const w=JSON.parse('{"title":"14增量构建：Webpack中的增量构建","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/104-前端工程化精讲文档/(4428) 14  增量构建：Webpack 中的增量构建.md","filePath":"posts/frontEnd/104-前端工程化精讲文档/(4428) 14  增量构建：Webpack 中的增量构建.md","lastUpdated":1718371218000}'),k={name:"posts/frontEnd/104-前端工程化精讲文档/(4428) 14  增量构建：Webpack 中的增量构建.md"},r=h("",8),c=h("",4),E=h("",4),g=n("p",null,[s("正如我们所期望的，再次构建时，在编译模块阶段只对有变化的文件进行了重新编译，实现了"),n("strong",null,"增量编译"),s("的效果。")],-1),d=n("p",null,"但是美中不足的是，在优化阶段压缩代码时仍然耗费了较多的时间。这一点很容易理解：",-1),o=n("p",null,"体积最大的 react、react-dom 等模块和入口模块打入了同一个 Chunk 中，即使修改的模块是单独分离的 bar.js，但它的产物名称的变化仍然需要反映在入口 Chunk 的 runtime 模块中。因此入口 Chunk 也需要跟着重新压缩而无法复用压缩缓存数据。根据前面几节课的知识点，我们对配置再做一些优化，将 vendor 分离后再来看看效果，如下面的图片所示：",-1),y=h("",25);function u(b,F,_,C,m,A){const i=p("Image");return l(),e("div",null,[r,a(i,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/57/0E/CgqCHl9sTsWAbetxAAGoldlDrIw704.png"}),s(),a(i,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/57/03/Ciqc1F9sTsmAJc8YAADz9x_Zsvo780.png"}),s(),c,a(i,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/57/0E/CgqCHl9sTtOAPzPRAAHMQJnGHlo474.png"}),s(),a(i,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/57/0E/CgqCHl9sTtiAB2seAAG0v0B0ORQ594.png"}),s(),E,a(i,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/57/0F/CgqCHl9sTuuAc0_4AAHBe2Lt3do732.png"}),s(),a(i,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/57/03/Ciqc1F9sTvCAY2NvAAEtJYxCA_8121.png"}),s(),g,d,o,a(i,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/57/0F/CgqCHl9sTvqAP1oIAAG2kbb-DGY688.png"}),s(),a(i,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image/M00/57/0F/CgqCHl9sTv6AYxTKAAFAsmUEZMg953.png"}),s(),y])}const f=t(k,[["render",u]]);export{w as __pageData,f as default};
