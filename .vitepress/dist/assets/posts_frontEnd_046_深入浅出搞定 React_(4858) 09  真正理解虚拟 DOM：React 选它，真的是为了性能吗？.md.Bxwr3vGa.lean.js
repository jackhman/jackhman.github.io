import{_ as p,F as l,g as e,K as i,h as s,ar as t,l as n,o as h}from"./chunks/framework.VlluEs-f.js";const f=JSON.parse('{"title":"09真正理解虚拟DOM：React选它，真的是为了性能吗？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/046_深入浅出搞定 React/(4858) 09  真正理解虚拟 DOM：React 选它，真的是为了性能吗？.md","filePath":"posts/frontEnd/046_深入浅出搞定 React/(4858) 09  真正理解虚拟 DOM：React 选它，真的是为了性能吗？.md","lastUpdated":1718371218000}'),o={name:"posts/frontEnd/046_深入浅出搞定 React/(4858) 09  真正理解虚拟 DOM：React 选它，真的是为了性能吗？.md"},k=t("",8),r=t("",43),E=n("p",null,"而在虚拟 DOM 的加持下，事情变成了这样：",-1),d=n("p",null,'注意图中的"模板"二字加了引号，这是因为虚拟 DOM 在实现上并不总是借助模板。比如 React 就使用了 JSX，前面咱们着重讲过，JSX 本质不是模板，而是一种使用体验和模板相似的 JS 语法糖。',-1),g=n("p",null,[s('区别就在于多出了一层虚拟 DOM 作为缓冲层。这个缓冲层带来的利好是：当 DOM 操作（渲染更新）比较频繁时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个"补丁集"，最后只把"补丁"打在需要更新的那部分真实 DOM 上，实现精准的"'),n("strong",null,"差量更新"),s('"。这个过程对应的虚拟 DOM 工作流如下图所示：')],-1),D=t("",8),c=t("",11),M=t("",7);function u(O,q,_,y,m,b){const a=l("Image");return h(),e("div",null,[k,i(a,{alt:"Lark20201106-192037.png",src:"https://s0.lgstatic.com/i/image/M00/68/F3/Ciqc1F-lMbGAZJopAAJVEWRSZj4098.png"}),s(),r,i(a,{alt:"Lark20201106-192050.png",src:"https://s0.lgstatic.com/i/image/M00/68/F3/Ciqc1F-lMciARJRWAABf3Qw2zLE639.png"}),s(),E,i(a,{alt:"Lark20201106-192053.png",src:"https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMdaAD-COAAB2DeSedec916.png"}),s(),d,g,i(a,{alt:"Lark20201106-192055.png",src:"https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMeWADhSdAABuVFS6_bo480.png"}),s(),D,i(a,{alt:"Lark20201106-192058.png",src:"https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMhKAbHiXAACFes1Uw30648.png"}),s(),i(a,{alt:"Lark20201106-192100.png",src:"https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMheAZqbEAACP9ZvpCP8374.png"}),s(),c,i(a,{alt:"Lark20201109-110626.png",src:"https://s0.lgstatic.com/i/image/M00/69/AE/CgqCHl-otLSAT1ivAACwY9bVkZQ836.png"}),s(),M])}const F=p(o,[["render",u]]);export{f as __pageData,F as default};
