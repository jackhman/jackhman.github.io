import{_ as l,F as h,g as p,K as n,h as i,l as s,ar as t,o as e}from"./chunks/framework.VlluEs-f.js";const q=JSON.parse('{"title":"24从Protocol起手，看服务暴露和服务引用的全流程（上）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4274) 24  从 Protocol 起手，看服务暴露和服务引用的全流程（上）.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4274) 24  从 Protocol 起手，看服务暴露和服务引用的全流程（上）.md","lastUpdated":1718371218000}'),k={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4274) 24  从 Protocol 起手，看服务暴露和服务引用的全流程（上）.md"},E=s("h1",{id:"_24从protocol起手-看服务暴露和服务引用的全流程-上",tabindex:"-1"},[i("24从Protocol起手，看服务暴露和服务引用的全流程（上） "),s("a",{class:"header-anchor",href:"#_24从protocol起手-看服务暴露和服务引用的全流程-上","aria-label":'Permalink to "24从Protocol起手，看服务暴露和服务引用的全流程（上）"'},"​")],-1),r=s("p",null,"在上一课时我们讲解了 Protocol 的核心接口，那本课时我们就以 Protocol 接口为核心，详细介绍整个 Protocol 的核心实现。下图展示了 Protocol 接口的继承关系：",-1),d=s("p",null,"Protocol 接口继承关系图",-1),g=s("p",null,[i("其中，"),s("strong",null,"AbstractProtocol"),i("提供了一些 Protocol 实现需要的公共能力以及公共字段，它的核心字段有如下三个。")],-1),o=s("ul",null,[s("li",null,"exporterMap（Map<String, Exporter<?>>类型）：用于存储出去的服务集合，其中的 Key 通过 ProtocolUtils.serviceKey() 方法创建的服务标识，在 ProtocolUtils 中维护了多层的 Map 结构（如下图所示）。首先按照 group 分组，在实践中我们可以根据需求设置 group，例如，按照机房、地域等进行 group 划分，做到就近调用；在 GroupServiceKeyCache 中，依次按照 serviceName、serviceVersion、port 进行分类，最终缓存的 serviceKey 是前面三者拼接而成的。")],-1),y=t("",9),c=s("p",null,"DubboExporter 继承关系图",-1),F=s("p",null,"AbstractExporter 中维护了一个 Invoker 对象，以及一个 unexported 字段（boolean 类型），在 unexport() 方法中会设置 unexported 字段为 true，并调用 Invoker 对象的 destory() 方法进行销毁。",-1),D=s("p",null,"DubboExporter 也比较简单，其中会维护底层 Invoker 对应的 ServiceKey 以及 DubboProtocol 中的 exportMap 集合，在其 unexport() 方法中除了会调用父类 AbstractExporter 的 unexport() 方法之外，还会清理该 DubboExporter 实例在 exportMap 中相应的元素。",-1),A=s("h4",{id:"_2-服务端初始化",tabindex:"-1"},[i("2. 服务端初始化 "),s("a",{class:"header-anchor",href:"#_2-服务端初始化","aria-label":'Permalink to "2. 服务端初始化"'},"​")],-1),u=s("p",null,"了解了 Exporter 实现之后，我们继续看 DubboProtocol 中服务发布的流程。从下面这张调用关系图中可以看出，openServer() 方法会一路调用前面介绍的 Exchange 层、Transport 层，并最终创建 NettyServer 来接收客户端的请求。",-1),C=t("",9),b=t("",4),v=t("",5),_=t("",4),m=t("",19),S=s("p",null,"getRegisteredClasses() 方法的调用位置",-1),B=s("p",null,"按照 Dubbo 官方文档的说法，即使不注册任何类进行优化，Kryo 和 FST 的性能依然普遍优于Hessian2 和 Dubbo 序列化。",-1),x=s("h3",{id:"总结",tabindex:"-1"},[i("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),I=s("p",null,"本课时我们重点介绍了 DubboProtocol 发布一个 Dubbo 服务的核心流程。首先，我们介绍了 AbstractProtocol 这个抽象类为 Protocol 实现类提供的公共能力和字段，然后我们结合 Dubbo 协议对应的 DubboProtocol 实现，讲解了发布一个 Dubbo 服务的核心流程，其中涉及整个服务端核心启动流程、RpcInvocation 实现、DubboProtocol.requestHandler 字段调用 Invoker 对象以及序列化相关的优化处理等内容。",-1),T=s("p",null,"下一课时，我们将继续介绍 DubboProtocol 引用服务的相关实现。",-1);function R(P,O,N,M,f,K){const a=h("Image");return e(),p("div",null,[E,r,n(a,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/5D/C5/Ciqc1F-FTHGAOVGKAAJe5PD5u9A015.png"}),i(),d,g,o,n(a,{alt:"Lark20201016-164613.png",src:"https://s0.lgstatic.com/i/image/M00/5F/74/Ciqc1F-JXfmAJK8RAAHUliqXmBc629.png"}),i(),y,n(a,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/5D/D0/CgqCHl-FTJSAd9oTAAAm0DgOmVo715.png"}),i(),c,F,D,A,u,n(a,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/5D/D0/CgqCHl-FTKGAJNO8AAElldtvsRM104.png"}),i(),C,n(a,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/5D/D0/CgqCHl-FTK-AUlLCAADTWhhySe8432.png"}),i(),b,n(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/5D/C5/Ciqc1F-FTLuAZ-AoAACeZ02hpEg723.png"}),i(),v,n(a,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/5D/D0/CgqCHl-FTMSAYeP7AAA_pzU2CPA016.png"}),i(),_,n(a,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image/M00/5D/C5/Ciqc1F-FTM2Ae73pAAC0_daI0N4088.png"}),i(),m,n(a,{alt:"Drawing 8.png",src:"https://s0.lgstatic.com/i/image/M00/5D/C5/Ciqc1F-FTOGAEWu7AADOU3xBmjA069.png"}),i(),S,B,x,I,T])}const z=l(k,[["render",R]]);export{q as __pageData,z as default};
