import{_ as h,F as t,g as l,K as i,h as a,ar as e,l as n,o as k}from"./chunks/framework.VlluEs-f.js";const R=JSON.parse('{"title":"21Exchange层剖析：彻底搞懂Requet-Repone模型（上）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4819) 21  Exchange 层剖析：彻底搞懂 Requet-Repone 模型（上）.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4819) 21  Exchange 层剖析：彻底搞懂 Requet-Repone 模型（上）.md","lastUpdated":1718371218000}'),p={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4819) 21  Exchange 层剖析：彻底搞懂 Requet-Repone 模型（上）.md"},E=e("",11),r=n("p",null,"ExchangeChannel 接口",-1),d=n("p",null,"其中，request() 方法负责发送请求，从图中可以看到这里有两个重载，其中一个重载可以指定请求的超时时间，返回值都是 Future 对象。",-1),g=e("",23),y=n("p",null,"ChannelHandler 继承关系总览图",-1),c=n("p",null,"HeaderExchangeHandler 作为一个装饰器，其 connected()、disconnected()、sent()、received()、caught() 方法最终都会转发给上层提供的 ExchangeHandler 进行处理。这里我们需要聚焦的是 HeaderExchangeHandler 本身对 Request 和 Response 的处理逻辑。",-1),u=e("",13);function o(F,D,A,C,m,x){const s=t("Image");return k(),l("div",null,[E,i(s,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/5A/32/Ciqc1F90Q-OAE4K1AADklLgEs0k481.png"}),a(),r,d,i(s,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/5A/3D/CgqCHl90Q_SAIt4sAAAzhH5TZiw571.png"}),a(),g,i(s,{alt:"Lark20201013-153600.png",src:"https://s0.lgstatic.com/i/image/M00/5D/D2/Ciqc1F-FWUqAVkr0AADiEwO4wK4124.png"}),a(),y,c,i(s,{alt:"Lark20201013-153557.png",src:"https://s0.lgstatic.com/i/image/M00/5D/D2/Ciqc1F-FWVeAbsckAAGeD-_NNHc225.png"}),a(),u])}const f=h(p,[["render",o]]);export{R as __pageData,f as default};
