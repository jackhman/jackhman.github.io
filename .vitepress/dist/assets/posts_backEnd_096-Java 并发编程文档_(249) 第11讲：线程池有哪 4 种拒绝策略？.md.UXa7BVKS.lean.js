import{_ as l,F as n,g as o,K as s,h as i,ar as e,l as t,o as h}from"./chunks/framework.VlluEs-f.js";const P=JSON.parse('{"title":"第11讲：线程池有哪4种拒绝策略？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/096-Java 并发编程文档/(249) 第11讲：线程池有哪 4 种拒绝策略？.md","filePath":"posts/backEnd/096-Java 并发编程文档/(249) 第11讲：线程池有哪 4 种拒绝策略？.md","lastUpdated":1718371218000}'),p={name:"posts/backEnd/096-Java 并发编程文档/(249) 第11讲：线程池有哪 4 种拒绝策略？.md"},r=e("",8),c=t("p",null,"我们结合图示来分析上述情况，首先看右侧上方的队列部分，你可以看到目前队列已经满了，而图中队列下方的每个线程都在工作，且线程数已经达到最大值 10，如果此时再有新的任务提交，线程池由于没有能力继续处理新提交的任务，所以就会拒绝。",-1),d=t("p",null,"我们了解了线程池拒绝任务的时机，那么我们如何正确地选择拒绝策略呢？Java 在 ThreadPoolExecutor 类中为我们提供了 4 种默认的拒绝策略来应对不同的场景，都实现了 RejectedExecutionHandler 接口，如图所示：",-1),_=e("",3);function k(E,g,u,m,y,A){const a=n("Image");return h(),o("div",null,[r,s(a,{alt:"",src:"https://s0.lgstatic.com/i/image2/M01/AE/90/CgoB5l3g0XCAWJKOAABzAQJB4SM657.png"}),i(),c,d,s(a,{alt:"",src:"https://s0.lgstatic.com/i/image2/M01/AE/B0/CgotOV3g0WWAVWVlAAEsBI6lEEA162.png"}),i(),_])}const T=l(p,[["render",k]]);export{P as __pageData,T as default};
