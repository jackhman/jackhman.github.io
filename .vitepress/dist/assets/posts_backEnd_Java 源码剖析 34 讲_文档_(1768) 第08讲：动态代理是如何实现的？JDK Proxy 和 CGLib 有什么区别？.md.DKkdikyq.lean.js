import{_ as l,F as t,g as p,K as a,h as n,ar as h,l as s,o as k}from"./chunks/framework.VlluEs-f.js";const B=JSON.parse('{"title":"第08讲：动态代理是如何实现的？JDKProxy和CGLib有什么区别？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Java 源码剖析 34 讲_文档/(1768) 第08讲：动态代理是如何实现的？JDK Proxy 和 CGLib 有什么区别？.md","filePath":"posts/backEnd/Java 源码剖析 34 讲_文档/(1768) 第08讲：动态代理是如何实现的？JDK Proxy 和 CGLib 有什么区别？.md","lastUpdated":1718371218000}'),e={name:"posts/backEnd/Java 源码剖析 34 讲_文档/(1768) 第08讲：动态代理是如何实现的？JDK Proxy 和 CGLib 有什么区别？.md"},E=h("",37),r=s("p",null,"接下来讲讲 Lombok 的原理。",-1),d=s("p",null,"Lombok 的实现和反射没有任何关系，前面我们说了反射是程序在运行期的一种自省（introspect）能力，而 Lombok 的实现是在编译期就完成了，为什么这么说呢？",-1),g=s("p",null,"回到我们刚才 Setter/Getter 的方法，当我们打开 Person 的编译类就会发现，使用了 Lombok 的 @Data 注解后的源码竟然是这样的：",-1),y=s("p",null,"可以看出 Lombok 是在编译期就为我们生成了对应的字节码。",-1),c=s("p",null,"其实 Lombok 是基于 Java 1.6 实现的 JSR 269: Pluggable Annotation Processing API 来实现的，也就是通过编译期自定义注解处理器来实现的，它的执行步骤如下：",-1),o=h("",8);function F(D,A,b,C,u,m){const i=t("Image");return k(),p("div",null,[E,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/09/05/Ciqah16HCB6AcjsPAAIhVz8yo1o620.png"}),n(),r,d,g,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/1B/Cgq2xl6HCB6AXaC5AAHG477g0yQ093.png"}),n(),y,c,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/1B/Cgq2xl6HCB-AAsAKAACfTHorgDA111.png"}),n(),o])}const x=l(e,[["render",F]]);export{B as __pageData,x as default};
