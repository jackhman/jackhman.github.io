import{_ as p,F as l,g as k,K as n,h as i,l as s,ar as h,o as t}from"./chunks/framework.VlluEs-f.js";const O=JSON.parse('{"title":"第25讲：Node.j==全栈？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/前端高手进阶_文档/(3197) 第25讲：Node.j == 全栈？.md","filePath":"posts/frontEnd/前端高手进阶_文档/(3197) 第25讲：Node.j == 全栈？.md","lastUpdated":1718371218000}'),e={name:"posts/frontEnd/前端高手进阶_文档/(3197) 第25讲：Node.j == 全栈？.md"},E=s("h1",{id:"第25讲-node-j-全栈",tabindex:"-1"},[i("第25讲：Node.j==全栈？ "),s("a",{class:"header-anchor",href:"#第25讲-node-j-全栈","aria-label":'Permalink to "第25讲：Node.j==全栈？"'},"​")],-1),r=s("p",null,"提到 Node.js，相信大部分前端工程师都会想到基于它来开发服务端，只需要掌握 JavaScript 一门语言就可以成为全栈工程师，但其实 Node.js 的意义并不仅于此。",-1),d=s("p",null,"很多高级语言，执行权限都可以触及操作系统，而运行在浏览器端的 JavaScript 则例外，浏览器为其创建的沙箱环境，把前端工程师封闭在一个编程世界的象牙塔里。不过 Node.js 的出现则弥补了这个缺憾，前端工程师也可以触达计算机世界的底层。",-1),g=s("p",null,"所以 Node.js 对于前端工程师的意义不仅在于提供了全栈开发能力，更重要的是为前端工程师打开了一扇通向计算机底层世界的大门。这一课时我们通过分析 Node.js 的实现原理来打开这扇大门。",-1),y=s("h3",{id:"node-js-源码结构",tabindex:"-1"},[i("Node.js 源码结构 "),s("a",{class:"header-anchor",href:"#node-js-源码结构","aria-label":'Permalink to "Node.js 源码结构"'},"​")],-1),o=s("p",null,"Node.js 源码仓库的 /deps 目录下有十几个依赖，其中既有 C 语言编写的模块（如 libuv、V8）也有 JavaScript 语言编写的模块（如 acorn、acorn-plugins），如下图所示。",-1),c=h("",6),F=s("p",null,"libuv 结构图",-1),_=s("br",null,null,-1),u=s("p",null,"我用黄色线框将图中模块分为了两部分，分别代表了两种不同的异步实现方式。",-1),C=s("p",null,[i('左边部分为网络 I/O 模块，在不同平台下有不同的实现机制，Linux 系统下通过 epoll 实现，OSX 和其他 BSD 系统采用 KQueue，SunOS 系统采用 Event ports，Windows 系统采用的是IOCP。由于涉及操作系统底层 API，理解起来比较复杂，这里就不多介绍了，对这些实现机制比较感兴趣的同学可以查阅这篇文章"'),s("a",{href:"https://cloud.tencent.com/developer/article/1373483",target:"_blank",rel:"noreferrer"},"各种 IO 复用模式之 select、poll、epoll、kqueue、iocp 分析"),i('"。')],-1),A=s("p",null,"右边部分包括文件 I/O 模块、DNS 模块和用户代码，通过线程池来实现异步操作。文件 I/O 与网络 I/O 不同，libuv 没有依赖于系统底层的 API，而是在全局线程池中执行阻塞的文件 I/O 操作。",-1),v=s("h3",{id:"libuv-中的事件轮询",tabindex:"-1"},[i("libuv 中的事件轮询 "),s("a",{class:"header-anchor",href:"#libuv-中的事件轮询","aria-label":'Permalink to "libuv 中的事件轮询"'},"​")],-1),D=s("p",null,"下图是 libuv 官网给出的事件轮询工作流程图，我们结合代码来一起分析。",-1),B=h("",46);function m(b,f,q,U,P,I){const a=l("Image");return t(),k("div",null,[E,r,d,g,y,o,n(a,{alt:"image.png",src:"https://s0.lgstatic.com/i/image/M00/46/40/Ciqc1F9EvvmAC2x9AAAVgzc1Izg188.png"}),i(),c,n(a,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/46/4C/CgqCHl9EvxCAf_yRAAD8dPwXfWE007.png"}),i(),F,_,u,C,A,v,D,n(a,{alt:"image (1).png",src:"https://s0.lgstatic.com/i/image/M00/46/4C/CgqCHl9EvySAMrSYAADR1tJd-r8402.png"}),i(),B])}const x=p(e,[["render",m]]);export{O as __pageData,x as default};
