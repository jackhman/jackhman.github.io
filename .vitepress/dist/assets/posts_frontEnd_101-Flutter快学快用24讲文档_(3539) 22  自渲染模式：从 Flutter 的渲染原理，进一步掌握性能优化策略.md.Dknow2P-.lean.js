import{_ as e,F as l,g as h,K as a,h as s,ar as t,l as n,o as p}from"./chunks/framework.VlluEs-f.js";const v=JSON.parse('{"title":"22自渲染模式：从Flutter的渲染原理，进一步掌握性能优化策略","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/101-Flutter快学快用24讲文档/(3539) 22  自渲染模式：从 Flutter 的渲染原理，进一步掌握性能优化策略.md","filePath":"posts/frontEnd/101-Flutter快学快用24讲文档/(3539) 22  自渲染模式：从 Flutter 的渲染原理，进一步掌握性能优化策略.md","lastUpdated":1718371218000}'),k={name:"posts/frontEnd/101-Flutter快学快用24讲文档/(3539) 22  自渲染模式：从 Flutter 的渲染原理，进一步掌握性能优化策略.md"},d=t("",6),r=t("",6),E=n("p",null,"图 2 Element 树结构",-1),g=n("p",null,"你有没有发现就一个非常简单的 Widget ，在 Flutter 中实际生成的 Element 树结构图是如此的复杂。你有没有发现在树的最底层才是我们使用的组件 FirstRoute->Center->Text->RichText（如图 2 中红色的部分）。了解完三棵树结构后，我们再来看下三棵树是如何进行转化的。",-1),c=n("h3",{id:"三棵树对应关系",tabindex:"-1"},[s("三棵树对应关系 "),n("a",{class:"header-anchor",href:"#三棵树对应关系","aria-label":'Permalink to "三棵树对应关系"'},"​")],-1),o=n("p",null,"在 Flutter 中，Widget 和 Element 树是一一对应的，但是与 RenderObject 不是一一对应的。因为有些 Widget 是不需要渲染的，比如我们上面测试代码中的 FirstRoute 就是不需要渲染的 Widget。最终只有 RenderObjectWidget 相关的 Widget 才会转化为 RenderObject，也只有这种类型才需要进行渲染。可以看下表格 1 所展示的三棵树部分类型的对应关系。",-1),y=t("",8),F=t("",17),u=t("",7),C=t("",27);function b(m,_,A,D,B,W){const i=l("Image");return p(),h("div",null,[d,a(i,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_i_CAfmbFAAJQmkbVhaU299.png"}),s(),r,a(i,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_i_uAHvbgAAFqAXyCe9s498.png"}),s(),E,g,c,o,a(i,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_jAWASaH5AABxjuioTcw001.png"}),s(),y,a(i,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_jBaAPZtCAADE5IavI9E126.png"}),s(),F,a(i,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_jEiAbM-GAAFJbtV_XLo642.png"}),s(),u,a(i,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_jJGATAlDAAFF3eMI6D8595.png"}),s(),C])}const R=e(k,[["render",b]]);export{v as __pageData,R as default};
