import{_ as t,F as e,g as p,K as a,h as n,ar as l,l as s,o as h}from"./chunks/framework.VlluEs-f.js";const m=JSON.parse('{"title":"第63讲：单例模式的双重检查锁模式为什么必须加volatile？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/096-Java 并发编程文档/(301) 第63讲：单例模式的双重检查锁模式为什么必须加 volatile？.md","filePath":"posts/backEnd/096-Java 并发编程文档/(301) 第63讲：单例模式的双重检查锁模式为什么必须加 volatile？.md","lastUpdated":1718371218000}'),k={name:"posts/backEnd/096-Java 并发编程文档/(301) 第63讲：单例模式的双重检查锁模式为什么必须加 volatile？.md"},o=l("",12),r=l("",12),c=s("ul",null,[s("li",null,[s("p",null,"第一步是给 singleton 分配内存空间；")]),s("li",null,[s("p",null,"然后第二步开始调用 Singleton 的构造函数等，来初始化 singleton；")]),s("li",null,[s("p",null,"最后第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。")])],-1),g=s("p",null,"这里需要留意一下 1-2-3 的顺序，因为存在指令重排序的优化，也就是说第2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。",-1),d=s("p",null,"如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错，详细流程如下图所示：",-1),E=l("",7);function _(u,y,v,A,b,F){const i=e("Image");return h(),p("div",null,[o,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/05/B6/Ciqah16BpV-AG9iPAAAf42nvy5s798.png"}),n(),r,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7E/CC/Cgq2xl6BpWCAMBaVAACFIdffjfM852.png"}),n(),c,g,d,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7E/CC/Cgq2xl6BpWCAB6QQAAEKacFd0CE542.png"}),n(),E])}const C=t(k,[["render",_]]);export{m as __pageData,C as default};
