import{_ as h,F as l,g as p,K as n,h as i,ar as t,l as s,o as k}from"./chunks/framework.VlluEs-f.js";const v=JSON.parse('{"title":"第31讲：如何保证接口的幂等性？常见的实现方案有哪些？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Java 源码剖析 34 讲_文档/(1791) 第31讲：如何保证接口的幂等性？常见的实现方案有哪些？.md","filePath":"posts/backEnd/Java 源码剖析 34 讲_文档/(1791) 第31讲：如何保证接口的幂等性？常见的实现方案有哪些？.md","lastUpdated":1718371218000}'),e={name:"posts/backEnd/Java 源码剖析 34 讲_文档/(1791) 第31讲：如何保证接口的幂等性？常见的实现方案有哪些？.md"},d=t("",14),E=t("",9),r=s("p",null,"JVM 锁执行流程图",-1),g=s("p",null,"JVM 锁存在的最大问题在于，它只能应用于单机环境，因为 Lock 本身为单机锁，所以它就不适应于分布式多机环境。",-1),o=s("h4",{id:"_4-分布式锁实现",tabindex:"-1"},[i("4. 分布式锁实现 "),s("a",{class:"header-anchor",href:"#_4-分布式锁实现","aria-label":'Permalink to "4. 分布式锁实现"'},"​")],-1),y=s("p",null,"分布式锁实现幂等性的逻辑是，在每次执行方法之前先判断是否可以获取到分布式锁，如果可以，则表示为第一次执行方法，否则直接舍弃请求即可，执行流程如下图所示：",-1),c=t("",40);function F(u,_,C,A,b,D){const a=l("Image");return k(),p("div",null,[d,n(a,{alt:"11111111111111111111.gif",src:"https://s0.lgstatic.com/i/image/M00/26/CC/CgqCHl7y9-yAHTg2AAICT3yhluA522.gif"}),i(),E,n(a,{alt:"2.png",src:"https://s0.lgstatic.com/i/image/M00/26/CF/CgqCHl7y-zKACO1KAADpJreXpQQ297.png"}),i(),r,g,o,y,n(a,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/26/C3/Ciqc1F7y-z6AVFbTAAB5lCnzVDg343.png"}),i(),c])}const q=h(e,[["render",F]]);export{v as __pageData,q as default};
