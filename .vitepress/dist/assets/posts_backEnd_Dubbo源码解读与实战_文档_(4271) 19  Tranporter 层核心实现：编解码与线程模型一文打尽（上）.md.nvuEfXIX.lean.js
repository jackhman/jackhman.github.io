import{_ as h,F as e,g as l,K as n,h as i,ar as t,l as s,o as p}from"./chunks/framework.VlluEs-f.js";const f=JSON.parse('{"title":"19Tranporter层核心实现：编解码与线程模型一文打尽（上）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4271) 19  Tranporter 层核心实现：编解码与线程模型一文打尽（上）.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4271) 19  Tranporter 层核心实现：编解码与线程模型一文打尽（上）.md","lastUpdated":1718371218000}'),k={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4271) 19  Tranporter 层核心实现：编解码与线程模型一文打尽（上）.md"},r=t("",4),E=t("",12),d=t("",11),g=t("",16),y=s("p",null,"NettyServer 模型",-1),o=s("h4",{id:"核心-channelhandler",tabindex:"-1"},[i("核心 ChannelHandler "),s("a",{class:"header-anchor",href:"#核心-channelhandler","aria-label":'Permalink to "核心 ChannelHandler"'},"​")],-1),c=s("p",null,"下面我们来逐个看看这四个 ChannelHandler 的核心功能。",-1),F=s("p",null,[i("首先是"),s("strong",null,"decoder 和 encoder"),i("，它们都是 NettyCodecAdapter 的内部类，如下图所示，分别继承了 Netty 中的 ByteToMessageDecoder 和 MessageToByteEncoder：")],-1),A=t("",6),C=s("p",null,"NettyServerHandler 继承关系图",-1),u=s("p",null,"在 NettyServerHandler 中有 channels 和 handler 两个核心字段。",-1),D=s("ul",null,[s("li",null,"channels（Map<String,Channel>集合）：记录了当前 Server 创建的所有 Channel，从下图中可以看到，连接创建（触发 channelActive() 方法）、连接断开（触发 channelInactive()方法）会操作 channels 集合进行相应的增删。")],-1),b=s("ul",null,[s("li",null,"handler（ChannelHandler 类型）：NettyServerHandler 内几乎所有方法都会触发该 Dubbo ChannelHandler 对象（如下图）。")],-1),_=t("",5),B=s("p",null,"也就是说，NettyServerHandler 会将数据委托给这个 ChannelHandler。",-1),v=s("p",null,"到此为止，Server 这条继承线就介绍完了。你可以回顾一下，从 AbstractPeer 开始往下，一路继承下来，NettyServer 拥有了 Endpoint、ChannelHandler 以及RemotingServer多个接口的能力，关联了一个 ChannelHandler 对象以及 Codec2 对象，并最终将数据委托给这两个对象进行处理。所以，上层调用方只需要实现 ChannelHandler 和 Codec2 这两个接口就可以了。",-1),m=s("h3",{id:"总结",tabindex:"-1"},[i("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),T=s("p",null,"本课时重点介绍了 Dubbo Transporter 层中 Server 相关的实现。",-1),S=s("p",null,"首先，我们介绍了 AbstractPeer 这个最顶层的抽象类，了解了 Server、Client 和 Channel 的公共属性。接下来，介绍了 AbstractEndpoint 抽象类，它提供了编解码等 Server 和 Client 所需的公共能力。最后，我们深入分析了 AbstractServer 抽象类以及基于 Netty 4 实现的 NettyServer，同时，还深入剖析了涉及的各种组件，例如，ExecutorRepository、NettyServerHandler 等。",-1);function x(P,I,N,R,L,U){const a=e("Image");return p(),l("div",null,[r,n(a,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/58/F3/Ciqc1F9wb8eAHyD_AAFkwn8xp18694.png"}),i(),E,n(a,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/58/F3/Ciqc1F9wb-iAMAgtAACJWi59iSc812.png"}),i(),d,n(a,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/58/FE/CgqCHl9wcBeAYMZ1AABRTGzl5uY627.png"}),i(),g,n(a,{alt:"5.png",src:"https://s0.lgstatic.com/i/image/M00/59/E4/Ciqc1F9y4LaAIHSsAADBytWDQ3U695.png"}),i(),y,o,c,F,n(a,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/58/FE/CgqCHl9wcESANfPCAABDUdzhtNU066.png"}),i(),A,n(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/58/F3/Ciqc1F9wcFKAQQZ3AAB282frbWw282.png"}),i(),C,u,D,n(a,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/58/F3/Ciqc1F9wcFuABJWsAAaIoTwCIA0958.png"}),i(),b,n(a,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image/M00/58/FE/CgqCHl9wcGOAE_ykAAFvy5a4X58367.png"}),i(),_,n(a,{alt:"Drawing 8.png",src:"https://s0.lgstatic.com/i/image/M00/58/F3/Ciqc1F9wcGuADQi3AAD6EEURlNU871.png"}),i(),B,v,n(a,{alt:"6.png",src:"https://s0.lgstatic.com/i/image/M00/59/E4/Ciqc1F9y4MyAR8XLAABTLdOZqrc228.png"}),i(),m,T,S])}const w=h(k,[["render",x]]);export{f as __pageData,w as default};
